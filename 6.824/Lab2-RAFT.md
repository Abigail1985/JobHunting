
# 6.824 - 春季 2020

## 6.824 实验室 2: Raft

### 截止日期
- **Part 2A 截止**: 2月21日 23:59
- **Part 2B 截止**: 2月28日 23:59
- **Part 2C 截止**: 3月6日 23:59

### 引言

这是一系列实验室中的第一个，在这里你将构建一个容错的键/值存储系统。在本实验室中，你将实现 Raft，一个复制状态机协议。在下一个实验室中，你将在 Raft 的基础上构建一个键/值服务。然后，你将通过多个复制状态机“分片”你的服务以获得更高的性能。

复制服务通过在多个副本服务器上存储其状态（即数据）的完整副本来实现容错。复制允许服务即使在其一些服务器遭遇故障（崩溃或网络故障）时也能继续运行。挑战在于，故障可能导致副本持有不同的数据副本。

Raft 将客户端请求组织成一个序列，称为日志，并确保所有副本服务器看到相同的日志。每个副本按日志顺序执行客户端请求，将其应用于服务状态的本地副本。由于所有活跃的副本看到相同的日志内容，它们都以相同的顺序执行相同的请求，因此继续拥有相同的服务状态。如果服务器失败但稍后恢复，Raft 将负责使其日志更新。只要至少有大多数服务器存活并能相互通信，Raft 就会继续运行。如果没有这样的多数，Raft 将不会取得进展，但只要多数能再次通信，它就会从中断的地方继续。

在本实验室中，你将实现 Raft 作为一个 Go 对象类型及其相关方法，意图用作更大服务中的一个模块。一组 Raft 实例通过 RPC 相互通信以维护复制日志。你的 Raft 接口将支持无限序列的编号命令，也称为日志条目。条目用索引号编号。给定索引的日志条目最终将被提交。届时，你的 Raft 应该将日志条目发送到更大的服务以执行。

你应该按照扩展 Raft 论文中的设计，特别注意图 2。你将实现论文中的大部分内容，包括保存持久状态并在节点失败后重启时读取它。你将不实现群集成员资格变更（第6节）。你将在后面的实验室中实现日志压缩/快照（第7节）。

你可能会发现[这个指南](#)以及关于[锁定和并发结构的建议](#)很有用。为了获得更广泛的视角，可以看看 Paxos、Chubby、Paxos Made Live、Spanner、Zookeeper、Harp、Viewstamped Replication 和 Bolosky 等。

这个实验室分三个部分提交。你必须在相应的截止日期提交每个部分。

### 合作政策

你必须亲自编写你提交的 6.824 的所有代码，除了我们作为作业的一部分给你的代码。你不得查看其他人的解决方案，不得查看往年的代码，也不得查看其他 Raft 实现。你可以与其他学生讨论作业，但你不

得查看或复制其他人的代码，也不允许其他人查看你的代码。
请不要发布你的代码或使其对当前或未来的 6.824 学生可用。github.com 存储库默认是公开的，因此请不要把你的代码放在那里，除非你将存储库设为私有。你可能会发现使用 MIT 的 GitHub 很方便，但请确保创建一个私有存储库。

### 入门

如果你已经完成了实验室 1，那么你已经有了实验室源代码的副本。如果没有，你可以在实验室 1 的指南中找到通过 git 获取源代码的方向。

我们为你提供了骨架代码 `src/raft/raft.go`。我们还提供了一组测试，你应该使用它们来推动你的实现努力，我们也将使用它们来评估你提交的实验室。测试位于 `src/raft/test_test.go` 中。

要开始，请执行以下命令。不要忘记 `git pull` 以获取最新软件。

```bash
$ cd ~/6.824
$ git pull
...
$ cd src/raft
$ go test
Test (2A): initial election ...
--- FAIL: TestInitialElection2A (5.04s)
        config.go:326: expected one leader, got none
Test (2A): election after network failure ...
--- FAIL: TestReElection2A (5.03s)
        config.go:326: expected one leader, got none
...
```


## 代码

通过向 `raft/raft.go` 添加代码来实现 Raft。在该文件中，你会找到骨架代码，以及如何发送和接收 RPC 的示例。
你的实现必须支持以下接口，测试者和（最终）你的键/值服务器将使用这些接口。你将在 `raft.go` 中的注释中找到更多细节。

```go
// 创建一个新的 Raft 服务器实例：
rf := Make(peers, me, persister, applyCh)

// 开始就一个新的日志条目达成一致：
rf.Start(command interface{}) (index, term, isleader)

// 询问一个 Raft 它当前的任期，并判断它是否认为自己是领导者
rf.GetState() (term, isLeader)

// 每当一个新的条目提交到日志中，每个 Raft 对等方
// 应该向服务（或测试者）发送一个 ApplyMsg。
type ApplyMsg
```

服务调用 `Make(peers, me, ...)` 来创建一个 Raft 对等方。`peers` 参数是 Raft 对等方（包括这个）的网络标识符数组，用于 RPC。`me` 参数是这个对等方在 `peers` 数组中的索引。`Start(command)` 要求 Raft 开始处理将命令附加到复制日志中。`Start()` 应该立即返回，而不等待日志追加完成。服务期望你的实现为每个新提交的日志条目通过 `Make()` 的 `applyCh` 频道参数发送一个 `ApplyMsg`。

`raft.go` 包含发送 RPC (`sendRequestVote()`) 和处理传入 RPC (`RequestVote()`) 的示例代码。你的 Raft 对等方应该使用 labrpc Go 包（源代码在 `src/labrpc` 中）交换 RPC。测试者可以告诉 labrpc 延迟 RPC、重新排序它们，并丢弃它们以模拟各种网络故障。虽然你可以暂时修改 labrpc，但请确保你的 Raft 能与原始的 labrpc 一起工作，因为我们将使用它来测试和评估你的实验室。你的 Raft 实例必须仅通过 RPC 互动；例如，它们不允许使用共享的 Go 变量或文件进行通信。

后续实验室将基于本实验室，因此重要的是给自己足够的时间编写稳固的代码。



## 第2A部分

实现 Raft 领导者选举和心跳机制（没有日志条目的 AppendEntries RPC）。第2A部分的目标是选举出一个领导者，如果没有故障，领导者应保持领导地位，如果旧领导者失败或与旧领导者的数据包丢失，新领导者应接管领导。运行 `go test -run 2A` 来测试你的 2A 代码。

你不能轻易直接运行你的 Raft 实现；相反，你应该通过测试者运行它，即 `go test -run 2A`。
遵循论文的图 2。此时，你关注的是发送和接收 RequestVote RPC，与选举相关的服务器规则，以及与领导者选举相关的状态。
在 `raft.go` 的 Raft 结构中添加图 2 的领导者选举状态。你还需要定义一个结构来保存每个日志条目的信息。
填写 `RequestVoteArgs` 和 `RequestVoteReply` 结构。修改 `Make()` 创建一个后台协程，该协程将通过在一段时间内没有听到其他对等方的消息时发送 RequestVote RPC 来定期启动领导者选举。这样，对等方将了解谁是领导者，如果已有领导者，或者自己成为领导者。
要实现心跳机制，定义一个 AppendEntries RPC 结构（尽管你可能还不需要所有参数），并让领导者定期发送它们。编写一个 AppendEntries RPC 处理方法，以重置选举超时，以便在已经选出领导者时，其他服务器不会作为领导者站出来。
确保不同对等方的选举超时不会始终同时触发，否则所有对等方只会为自己投票，没有人会成为领导者。
测试者要求领导者每秒发送不超过十次心跳 RPC。
测试者要求你的 Raft 在旧领导者失败后五秒内选出新领导者（如果大多数对等方仍然能够通信）。然而，请记住，如果出现分票（可能是由于数据包丢失或候选人不幸选择了相同的随机后退时间），领导者选举可能需要多轮。
论文第 5.2 节提到选举超时在 150 到 300 毫秒的范围内。这样的范围只有在领导者发送心跳的频率远远超过每 150 毫秒一次时才有意义。由于测试者限制你每秒发送 10 次心跳，你将不得不使用比论文中的 150 到 300 毫秒更长的选举超时，但不要太长，因为那样你可能无法在五秒内选出领导者。
你可能会发现 Go 的 `rand` 很有用。
你需要编写代码定期或在时间延迟后采取行动。最简单的方法是创建一个循环调用 `time.Sleep()` 的协程。不要使用 Go 的 `time.Timer` 或 `time.Ticker`，它们很难正确使用。
阅读关于锁定和结构的建议。
如果你的代码在通过测试时遇到困难，请再次阅读论文的图 2；领导者选举的完整逻辑分布在图的多个部分。
不要忘记实现 `GetState()`。
测试者在永久关闭一个实例时调用你的 Raft 的 `rf.Kill()`。你可以使用 `rf.killed()` 检查是否已经调用了 `Kill()`。你可能希望在所有循环中都这样做，以避

免已经死亡的 Raft 实例打印令人困惑的信息。
调试代码的一个好方法是在对等方发送或接收消息时插入打印语句，并使用 `go test -run 2A > out` 将输出收集到一个文件中。然后，通过研究 `out` 文件中的消息轨迹，你可以确定你的实现与期望的协议有何偏差。你可能会发现 `util.go` 中的 `DPrintf` 对于在调试不同问题时开启和关闭打印非常有用。
Go RPC 只发送名称以大写字母开头的结构字段。子结构也必须有大写的字段名（例如数组中的日志记录字段）。`labgob` 包会对此发出警告；不要忽视这些警告。
使用 `go test -race` 检查你的代码，并修复它报告的任何竞争。
确保你在提交第2A部分之前通过了 2A 测试，这样你会看到类似这样的东西：

```bash
$ go test -run 2A
Test (2A): initial election ...
  ... Passed --   4.0  3   32    9170    0
Test (2A): election after network failure ...
  ... Passed --   6.1  3   70   13895    0
PASS
ok      raft    10.187s
$
```

每个 "通过" 行包含五个数字；这些是测试所用的秒数、Raft 对等方的数量（通常为 3 或 5）、测试期间发送的 RPC 数量、RPC 消息中的总字节数和 Raft 报告已提交的日志条目数。你的数字会与这里显示的不同。如果你愿意，你可以忽略这些数字，但它们可能会帮助你对你的实现发送的 RPC 数量进行合理性检查。对于实验室 2、3 和 4 的所有测试，如果所有测试（`go test`）总共超过 600 秒，或者任何单个测试超过 120 秒，评分脚本将判定你的解决方案失败。

### 实验室 2A 的提交程序

首先，请最后一次运行 2A 测试。然后，运行 `make lab2a` 将你的代码上传到提交网站。

你可以使用你的 MIT 证书或通过电子邮件请求 API 密钥来首次登录。你的 API 密钥（XXX）在登录后显示，可以使用以下方式从控制台上传实验室：

```bash
$ cd ~/6.824
$ echo "XXX" > api.key
$ make lab2a
```

检查提交网站以确保它看到了你的提交。

你可以多次提交。我们将使用你的最后一次提交来计算迟交天数。你的成绩取决于你的解决方案在我们运行测试者时可靠地获得的分数。

