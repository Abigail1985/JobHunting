
union的大小
野指针（临时变量放在栈上，离开函数就被销毁，出现野指针）

对象的大小

static

c语言实现字符串拷贝函数






### 对象的大小
在 C++ 中，一个对象的大小是由以下几个因素决定的：

1. **成员变量的大小**：对象大小的主要组成部分是其所有非静态成员变量的大小之和。这包括所有基本数据类型、对象、结构体和数组成员的大小。

2. **对齐填充（Padding）**：为了提高内存访问效率，编译器可能会在成员变量之间插入额外的填充字节，以确保每个成员变量都按其自然对齐方式存储。这种对齐通常是根据成员变量中最大的数据类型来确定的。

3. **虚函数表指针（vptr）**：如果类有虚函数（或者类继承自一个包含虚函数的基类），则对象需要存储一个指向虚函数表（vtable）的指针。这个指针的大小通常等同于一个指针类型的大小。

4. **虚继承**：在使用虚继承的情况下，可能会有额外的存储需求，比如指向虚基类的指针。

5. **空类大小**：一个完全空的类（没有任何成员变量和成员函数）在 C++ 中的大小不是0，而是至少为1字节，以确保每个对象都有一个独一无二的地址。

6. **编译器特定的实现**：不同的编译器可能会有不同的内存布局策略，这也可能影响对象的最终大小。

因此，一个对象的大小是由其成员变量、可能的填充字节、虚函数表指针等因素综合决定的。可以使用 `sizeof` 操作符来获取一个对象或类型的大小。


### c语言实现字符串拷贝函数
在 C 语言中编写一个类似于 `strcpy` 的字符串拷贝函数是一个基础且重要的练习。以下是一个简单实现的例子：

```c
#include <stdio.h>

void my_strcpy(char *dest, const char *src) {
    // 检查源字符串和目标字符串是否为NULL
    if (src == NULL || dest == NULL) {
        return;
    }

    // 拷贝字符直到遇到字符串结束符 '\0'
    while (*src) {
        *dest = *src;
        dest++;
        src++;
    }

    // 添加字符串结束符
    *dest = '\0';
}

int main() {
    char source[] = "Hello, world!";
    char destination[50];

    my_strcpy(destination, source);

    printf("Copied string: %s\n", destination);

    return 0;
}
```

这个 `my_strcpy` 函数接受两个参数：`dest`（目标字符串的指针）和 `src`（源字符串的指针）。函数的工作原理如下：

1. 首先检查 `src` 和 `dest` 是否为 `NULL`，以防止潜在的空指针解引用。

2. 使用 `while` 循环逐个字符复制源字符串到目标字符串，直到遇到源字符串的结束字符 `\0`。

3. 循环结束后，确保在目标字符串的末尾添加 `\0` 字符以形成一个完整的字符串。

请注意，这个简单的实现没有考虑目标字符串缓冲区溢出的问题，这在实际应用中是非常重要的安全考虑。在实际编程中，应该使用更安全的函数，如 `strncpy`，或确保目标缓冲区足够大以避免溢出。